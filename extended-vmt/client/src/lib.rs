#![no_std]

// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::collections::BTreeMap;
#[allow(unused_imports)]
use sails_rs::{
    calls::{Activation, Call, Query, Remoting, RemotingAction},
    prelude::*,
    String,
};
pub struct ExtendedVmtFactory<R> {
    #[allow(dead_code)]
    remoting: R,
}
impl<R> ExtendedVmtFactory<R> {
    #[allow(unused)]
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::ExtendedVmtFactory for ExtendedVmtFactory<R> {
    type Args = R::Args;
    fn new(&self, name: String, symbol: String, decimals: u8) -> impl Activation<Args = R::Args> {
        RemotingAction::<_, extended_vmt_factory::io::New>::new(
            self.remoting.clone(),
            (name, symbol, decimals),
        )
    }
}

pub mod extended_vmt_factory {
    use super::*;
    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct New(());
        impl New {
            #[allow(dead_code)]
            pub fn encode_call(name: String, symbol: String, decimals: u8) -> Vec<u8> {
                <New as ActionIo>::encode_call(&(name, symbol, decimals))
            }
        }
        impl ActionIo for New {
            const ROUTE: &'static [u8] = &[12, 78, 101, 119];
            type Params = (String, String, u8);
            type Reply = ();
        }
    }
}
pub struct Vmt<R> {
    remoting: R,
}
impl<R> Vmt<R> {
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::Vmt for Vmt<R> {
    type Args = R::Args;
    fn burn(
        &mut self,
        from: ActorId,
        id: U256,
        amount: U256,
    ) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vmt::io::Burn>::new(self.remoting.clone(), (from, id, amount))
    }
    fn burn_batch(
        &mut self,
        from: ActorId,
        ids: Vec<U256>,
        amounts: Vec<U256>,
    ) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vmt::io::BurnBatch>::new(self.remoting.clone(), (from, ids, amounts))
    }
    fn grant_admin_role(&mut self, to: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vmt::io::GrantAdminRole>::new(self.remoting.clone(), to)
    }
    fn grant_burner_role(&mut self, to: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vmt::io::GrantBurnerRole>::new(self.remoting.clone(), to)
    }
    fn grant_minter_role(&mut self, to: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vmt::io::GrantMinterRole>::new(self.remoting.clone(), to)
    }
    fn mint(
        &mut self,
        to: ActorId,
        id: U256,
        amount: U256,
        token_metadata: Option<TokenMetadata>,
    ) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vmt::io::Mint>::new(
            self.remoting.clone(),
            (to, id, amount, token_metadata),
        )
    }
    fn mint_batch(
        &mut self,
        to: ActorId,
        ids: Vec<U256>,
        amounts: Vec<U256>,
        token_metadata: Vec<Option<TokenMetadata>>,
    ) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vmt::io::MintBatch>::new(
            self.remoting.clone(),
            (to, ids, amounts, token_metadata),
        )
    }
    fn revoke_admin_role(&mut self, from: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vmt::io::RevokeAdminRole>::new(self.remoting.clone(), from)
    }
    fn revoke_burner_role(&mut self, from: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vmt::io::RevokeBurnerRole>::new(self.remoting.clone(), from)
    }
    fn revoke_minter_role(&mut self, from: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vmt::io::RevokeMinterRole>::new(self.remoting.clone(), from)
    }
    /// Approves an `ActorId` (account) to transfer tokens on behalf of the owner (sender).
    /// If the approval is successful, it emits an `Approval` event.
    fn approve(&mut self, to: ActorId) -> impl Call<Output = bool, Args = R::Args> {
        RemotingAction::<_, vmt::io::Approve>::new(self.remoting.clone(), to)
    }
    /// Transfers multiple tokens in batch from one account (`from`) to another (`to`).
    /// This method transfers multiple token IDs and amounts simultaneously.
    fn batch_transfer_from(
        &mut self,
        from: ActorId,
        to: ActorId,
        ids: Vec<U256>,
        amounts: Vec<U256>,
    ) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vmt::io::BatchTransferFrom>::new(
            self.remoting.clone(),
            (from, to, ids, amounts),
        )
    }
    /// Transfers tokens from one account (`from`) to another (`to`) if the sender is allowed.
    /// Emits a `Transfer` event after a successful transfer.
    fn transfer_from(
        &mut self,
        from: ActorId,
        to: ActorId,
        id: U256,
        amount: U256,
    ) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vmt::io::TransferFrom>::new(
            self.remoting.clone(),
            (from, to, id, amount),
        )
    }
    fn admins(&self) -> impl Query<Output = Vec<ActorId>, Args = R::Args> {
        RemotingAction::<_, vmt::io::Admins>::new(self.remoting.clone(), ())
    }
    fn burners(&self) -> impl Query<Output = Vec<ActorId>, Args = R::Args> {
        RemotingAction::<_, vmt::io::Burners>::new(self.remoting.clone(), ())
    }
    fn minters(&self) -> impl Query<Output = Vec<ActorId>, Args = R::Args> {
        RemotingAction::<_, vmt::io::Minters>::new(self.remoting.clone(), ())
    }
    /// Returns the token balance of an account (`account`) for a specific token ID (`id`).
    fn balance_of(&self, account: ActorId, id: U256) -> impl Query<Output = U256, Args = R::Args> {
        RemotingAction::<_, vmt::io::BalanceOf>::new(self.remoting.clone(), (account, id))
    }
    /// Returns token account balances (`accounts`) for specific token identifiers (`ids`).
    fn balance_of_batch(
        &self,
        accounts: Vec<ActorId>,
        ids: Vec<U256>,
    ) -> impl Query<Output = Vec<U256>, Args = R::Args> {
        RemotingAction::<_, vmt::io::BalanceOfBatch>::new(self.remoting.clone(), (accounts, ids))
    }
    /// Returns the number of decimal places used for this token.
    fn decimals(&self) -> impl Query<Output = u8, Args = R::Args> {
        RemotingAction::<_, vmt::io::Decimals>::new(self.remoting.clone(), ())
    }
    /// Checks if a specific operator (`operator`) is approved to transfer tokens on behalf of `account`.
    /// Returns true if the operator is approved.
    fn is_approved(
        &self,
        account: ActorId,
        operator: ActorId,
    ) -> impl Query<Output = bool, Args = R::Args> {
        RemotingAction::<_, vmt::io::IsApproved>::new(self.remoting.clone(), (account, operator))
    }
    /// Returns the name of the token.
    fn name(&self) -> impl Query<Output = String, Args = R::Args> {
        RemotingAction::<_, vmt::io::Name>::new(self.remoting.clone(), ())
    }
    /// Returns the symbol of the token.
    fn symbol(&self) -> impl Query<Output = String, Args = R::Args> {
        RemotingAction::<_, vmt::io::Symbol>::new(self.remoting.clone(), ())
    }
    /// Returns the total supply of tokens in circulation.
    fn total_supply(&self) -> impl Query<Output = Vec<(U256, U256)>, Args = R::Args> {
        RemotingAction::<_, vmt::io::TotalSupply>::new(self.remoting.clone(), ())
    }
}

pub mod vmt {
    use super::*;

    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct Burn(());
        impl Burn {
            #[allow(dead_code)]
            pub fn encode_call(from: ActorId, id: U256, amount: U256) -> Vec<u8> {
                <Burn as ActionIo>::encode_call(&(from, id, amount))
            }
        }
        impl ActionIo for Burn {
            const ROUTE: &'static [u8] = &[12, 86, 109, 116, 16, 66, 117, 114, 110];
            type Params = (ActorId, U256, U256);
            type Reply = ();
        }
        pub struct BurnBatch(());
        impl BurnBatch {
            #[allow(dead_code)]
            pub fn encode_call(from: ActorId, ids: Vec<U256>, amounts: Vec<U256>) -> Vec<u8> {
                <BurnBatch as ActionIo>::encode_call(&(from, ids, amounts))
            }
        }
        impl ActionIo for BurnBatch {
            const ROUTE: &'static [u8] = &[
                12, 86, 109, 116, 36, 66, 117, 114, 110, 66, 97, 116, 99, 104,
            ];
            type Params = (ActorId, Vec<U256>, Vec<U256>);
            type Reply = ();
        }
        pub struct GrantAdminRole(());
        impl GrantAdminRole {
            #[allow(dead_code)]
            pub fn encode_call(to: ActorId) -> Vec<u8> {
                <GrantAdminRole as ActionIo>::encode_call(&to)
            }
        }
        impl ActionIo for GrantAdminRole {
            const ROUTE: &'static [u8] = &[
                12, 86, 109, 116, 56, 71, 114, 97, 110, 116, 65, 100, 109, 105, 110, 82, 111, 108,
                101,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct GrantBurnerRole(());
        impl GrantBurnerRole {
            #[allow(dead_code)]
            pub fn encode_call(to: ActorId) -> Vec<u8> {
                <GrantBurnerRole as ActionIo>::encode_call(&to)
            }
        }
        impl ActionIo for GrantBurnerRole {
            const ROUTE: &'static [u8] = &[
                12, 86, 109, 116, 60, 71, 114, 97, 110, 116, 66, 117, 114, 110, 101, 114, 82, 111,
                108, 101,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct GrantMinterRole(());
        impl GrantMinterRole {
            #[allow(dead_code)]
            pub fn encode_call(to: ActorId) -> Vec<u8> {
                <GrantMinterRole as ActionIo>::encode_call(&to)
            }
        }
        impl ActionIo for GrantMinterRole {
            const ROUTE: &'static [u8] = &[
                12, 86, 109, 116, 60, 71, 114, 97, 110, 116, 77, 105, 110, 116, 101, 114, 82, 111,
                108, 101,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct Mint(());
        impl Mint {
            #[allow(dead_code)]
            pub fn encode_call(
                to: ActorId,
                id: U256,
                amount: U256,
                token_metadata: Option<super::TokenMetadata>,
            ) -> Vec<u8> {
                <Mint as ActionIo>::encode_call(&(to, id, amount, token_metadata))
            }
        }
        impl ActionIo for Mint {
            const ROUTE: &'static [u8] = &[12, 86, 109, 116, 16, 77, 105, 110, 116];
            type Params = (ActorId, U256, U256, Option<super::TokenMetadata>);
            type Reply = ();
        }
        pub struct MintBatch(());
        impl MintBatch {
            #[allow(dead_code)]
            pub fn encode_call(
                to: ActorId,
                ids: Vec<U256>,
                amounts: Vec<U256>,
                token_metadata: Vec<Option<super::TokenMetadata>>,
            ) -> Vec<u8> {
                <MintBatch as ActionIo>::encode_call(&(to, ids, amounts, token_metadata))
            }
        }
        impl ActionIo for MintBatch {
            const ROUTE: &'static [u8] = &[
                12, 86, 109, 116, 36, 77, 105, 110, 116, 66, 97, 116, 99, 104,
            ];
            type Params = (
                ActorId,
                Vec<U256>,
                Vec<U256>,
                Vec<Option<super::TokenMetadata>>,
            );
            type Reply = ();
        }
        pub struct RevokeAdminRole(());
        impl RevokeAdminRole {
            #[allow(dead_code)]
            pub fn encode_call(from: ActorId) -> Vec<u8> {
                <RevokeAdminRole as ActionIo>::encode_call(&from)
            }
        }
        impl ActionIo for RevokeAdminRole {
            const ROUTE: &'static [u8] = &[
                12, 86, 109, 116, 60, 82, 101, 118, 111, 107, 101, 65, 100, 109, 105, 110, 82, 111,
                108, 101,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct RevokeBurnerRole(());
        impl RevokeBurnerRole {
            #[allow(dead_code)]
            pub fn encode_call(from: ActorId) -> Vec<u8> {
                <RevokeBurnerRole as ActionIo>::encode_call(&from)
            }
        }
        impl ActionIo for RevokeBurnerRole {
            const ROUTE: &'static [u8] = &[
                12, 86, 109, 116, 64, 82, 101, 118, 111, 107, 101, 66, 117, 114, 110, 101, 114, 82,
                111, 108, 101,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct RevokeMinterRole(());
        impl RevokeMinterRole {
            #[allow(dead_code)]
            pub fn encode_call(from: ActorId) -> Vec<u8> {
                <RevokeMinterRole as ActionIo>::encode_call(&from)
            }
        }
        impl ActionIo for RevokeMinterRole {
            const ROUTE: &'static [u8] = &[
                12, 86, 109, 116, 64, 82, 101, 118, 111, 107, 101, 77, 105, 110, 116, 101, 114, 82,
                111, 108, 101,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct Approve(());
        impl Approve {
            #[allow(dead_code)]
            pub fn encode_call(to: ActorId) -> Vec<u8> {
                <Approve as ActionIo>::encode_call(&to)
            }
        }
        impl ActionIo for Approve {
            const ROUTE: &'static [u8] = &[12, 86, 109, 116, 28, 65, 112, 112, 114, 111, 118, 101];
            type Params = ActorId;
            type Reply = bool;
        }
        pub struct BatchTransferFrom(());
        impl BatchTransferFrom {
            #[allow(dead_code)]
            pub fn encode_call(
                from: ActorId,
                to: ActorId,
                ids: Vec<U256>,
                amounts: Vec<U256>,
            ) -> Vec<u8> {
                <BatchTransferFrom as ActionIo>::encode_call(&(from, to, ids, amounts))
            }
        }
        impl ActionIo for BatchTransferFrom {
            const ROUTE: &'static [u8] = &[
                12, 86, 109, 116, 68, 66, 97, 116, 99, 104, 84, 114, 97, 110, 115, 102, 101, 114,
                70, 114, 111, 109,
            ];
            type Params = (ActorId, ActorId, Vec<U256>, Vec<U256>);
            type Reply = ();
        }
        pub struct TransferFrom(());
        impl TransferFrom {
            #[allow(dead_code)]
            pub fn encode_call(from: ActorId, to: ActorId, id: U256, amount: U256) -> Vec<u8> {
                <TransferFrom as ActionIo>::encode_call(&(from, to, id, amount))
            }
        }
        impl ActionIo for TransferFrom {
            const ROUTE: &'static [u8] = &[
                12, 86, 109, 116, 48, 84, 114, 97, 110, 115, 102, 101, 114, 70, 114, 111, 109,
            ];
            type Params = (ActorId, ActorId, U256, U256);
            type Reply = ();
        }
        pub struct Admins(());
        impl Admins {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Admins as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Admins {
            const ROUTE: &'static [u8] = &[12, 86, 109, 116, 24, 65, 100, 109, 105, 110, 115];
            type Params = ();
            type Reply = Vec<ActorId>;
        }
        pub struct Burners(());
        impl Burners {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Burners as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Burners {
            const ROUTE: &'static [u8] = &[12, 86, 109, 116, 28, 66, 117, 114, 110, 101, 114, 115];
            type Params = ();
            type Reply = Vec<ActorId>;
        }
        pub struct Minters(());
        impl Minters {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Minters as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Minters {
            const ROUTE: &'static [u8] = &[12, 86, 109, 116, 28, 77, 105, 110, 116, 101, 114, 115];
            type Params = ();
            type Reply = Vec<ActorId>;
        }
        pub struct BalanceOf(());
        impl BalanceOf {
            #[allow(dead_code)]
            pub fn encode_call(account: ActorId, id: U256) -> Vec<u8> {
                <BalanceOf as ActionIo>::encode_call(&(account, id))
            }
        }
        impl ActionIo for BalanceOf {
            const ROUTE: &'static [u8] =
                &[12, 86, 109, 116, 36, 66, 97, 108, 97, 110, 99, 101, 79, 102];
            type Params = (ActorId, U256);
            type Reply = U256;
        }
        pub struct BalanceOfBatch(());
        impl BalanceOfBatch {
            #[allow(dead_code)]
            pub fn encode_call(accounts: Vec<ActorId>, ids: Vec<U256>) -> Vec<u8> {
                <BalanceOfBatch as ActionIo>::encode_call(&(accounts, ids))
            }
        }
        impl ActionIo for BalanceOfBatch {
            const ROUTE: &'static [u8] = &[
                12, 86, 109, 116, 56, 66, 97, 108, 97, 110, 99, 101, 79, 102, 66, 97, 116, 99, 104,
            ];
            type Params = (Vec<ActorId>, Vec<U256>);
            type Reply = Vec<U256>;
        }
        pub struct Decimals(());
        impl Decimals {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Decimals as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Decimals {
            const ROUTE: &'static [u8] =
                &[12, 86, 109, 116, 32, 68, 101, 99, 105, 109, 97, 108, 115];
            type Params = ();
            type Reply = u8;
        }
        pub struct IsApproved(());
        impl IsApproved {
            #[allow(dead_code)]
            pub fn encode_call(account: ActorId, operator: ActorId) -> Vec<u8> {
                <IsApproved as ActionIo>::encode_call(&(account, operator))
            }
        }
        impl ActionIo for IsApproved {
            const ROUTE: &'static [u8] = &[
                12, 86, 109, 116, 40, 73, 115, 65, 112, 112, 114, 111, 118, 101, 100,
            ];
            type Params = (ActorId, ActorId);
            type Reply = bool;
        }
        pub struct Name(());
        impl Name {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Name as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Name {
            const ROUTE: &'static [u8] = &[12, 86, 109, 116, 16, 78, 97, 109, 101];
            type Params = ();
            type Reply = String;
        }
        pub struct Symbol(());
        impl Symbol {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Symbol as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Symbol {
            const ROUTE: &'static [u8] = &[12, 86, 109, 116, 24, 83, 121, 109, 98, 111, 108];
            type Params = ();
            type Reply = String;
        }
        pub struct TotalSupply(());
        impl TotalSupply {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <TotalSupply as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for TotalSupply {
            const ROUTE: &'static [u8] = &[
                12, 86, 109, 116, 44, 84, 111, 116, 97, 108, 83, 117, 112, 112, 108, 121,
            ];
            type Params = ();
            type Reply = Vec<(U256, U256)>;
        }
    }

    #[allow(dead_code)]
    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        use sails_rs::events::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum VmtEvents {
            Minted {
                to: ActorId,
                ids: Vec<U256>,
                amounts: Vec<U256>,
            },
            Burned {
                from: ActorId,
                ids: Vec<U256>,
                amounts: Vec<U256>,
            },
            Approval {
                from: ActorId,
                to: ActorId,
            },
            Transfer {
                from: ActorId,
                to: ActorId,
                ids: Vec<U256>,
                amounts: Vec<U256>,
            },
        }
        impl EventIo for VmtEvents {
            const ROUTE: &'static [u8] = &[12, 86, 109, 116];
            const EVENT_NAMES: &'static [&'static [u8]] = &[
                &[24, 77, 105, 110, 116, 101, 100],
                &[24, 66, 117, 114, 110, 101, 100],
                &[32, 65, 112, 112, 114, 111, 118, 97, 108],
                &[32, 84, 114, 97, 110, 115, 102, 101, 114],
            ];
            type Event = Self;
        }
        pub fn listener<R: Listener<Vec<u8>>>(remoting: R) -> impl Listener<VmtEvents> {
            RemotingListener::<_, VmtEvents>::new(remoting)
        }
    }
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct TokenMetadata {
    pub title: Option<String>,
    pub description: Option<String>,
    pub media: Option<String>,
    pub reference: Option<String>,
}

pub mod traits {
    use super::*;
    #[allow(dead_code)]
    pub trait ExtendedVmtFactory {
        type Args;
        #[allow(clippy::new_ret_no_self)]
        #[allow(clippy::wrong_self_convention)]
        fn new(
            &self,
            name: String,
            symbol: String,
            decimals: u8,
        ) -> impl Activation<Args = Self::Args>;
    }

    #[allow(clippy::type_complexity)]
    pub trait Vmt {
        type Args;
        fn burn(
            &mut self,
            from: ActorId,
            id: U256,
            amount: U256,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn burn_batch(
            &mut self,
            from: ActorId,
            ids: Vec<U256>,
            amounts: Vec<U256>,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn grant_admin_role(&mut self, to: ActorId) -> impl Call<Output = (), Args = Self::Args>;
        fn grant_burner_role(&mut self, to: ActorId) -> impl Call<Output = (), Args = Self::Args>;
        fn grant_minter_role(&mut self, to: ActorId) -> impl Call<Output = (), Args = Self::Args>;
        fn mint(
            &mut self,
            to: ActorId,
            id: U256,
            amount: U256,
            token_metadata: Option<TokenMetadata>,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn mint_batch(
            &mut self,
            to: ActorId,
            ids: Vec<U256>,
            amounts: Vec<U256>,
            token_metadata: Vec<Option<TokenMetadata>>,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn revoke_admin_role(&mut self, from: ActorId)
            -> impl Call<Output = (), Args = Self::Args>;
        fn revoke_burner_role(
            &mut self,
            from: ActorId,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn revoke_minter_role(
            &mut self,
            from: ActorId,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn approve(&mut self, to: ActorId) -> impl Call<Output = bool, Args = Self::Args>;
        fn batch_transfer_from(
            &mut self,
            from: ActorId,
            to: ActorId,
            ids: Vec<U256>,
            amounts: Vec<U256>,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn transfer_from(
            &mut self,
            from: ActorId,
            to: ActorId,
            id: U256,
            amount: U256,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn admins(&self) -> impl Query<Output = Vec<ActorId>, Args = Self::Args>;
        fn burners(&self) -> impl Query<Output = Vec<ActorId>, Args = Self::Args>;
        fn minters(&self) -> impl Query<Output = Vec<ActorId>, Args = Self::Args>;
        fn balance_of(
            &self,
            account: ActorId,
            id: U256,
        ) -> impl Query<Output = U256, Args = Self::Args>;
        fn balance_of_batch(
            &self,
            accounts: Vec<ActorId>,
            ids: Vec<U256>,
        ) -> impl Query<Output = Vec<U256>, Args = Self::Args>;
        fn decimals(&self) -> impl Query<Output = u8, Args = Self::Args>;
        fn is_approved(
            &self,
            account: ActorId,
            operator: ActorId,
        ) -> impl Query<Output = bool, Args = Self::Args>;
        fn name(&self) -> impl Query<Output = String, Args = Self::Args>;
        fn symbol(&self) -> impl Query<Output = String, Args = Self::Args>;
        fn total_supply(&self) -> impl Query<Output = Vec<(U256, U256)>, Args = Self::Args>;
    }
}
