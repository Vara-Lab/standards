// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::collections::BTreeMap;
#[allow(unused_imports)]
use sails_rs::{
    calls::{Activation, Call, Query, Remoting, RemotingAction},
    prelude::*,
    String,
};
pub struct ExtendedVnftFactory<R> {
    #[allow(dead_code)]
    remoting: R,
}
impl<R> ExtendedVnftFactory<R> {
    #[allow(unused)]
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::ExtendedVnftFactory for ExtendedVnftFactory<R> {
    type Args = R::Args;
    fn new(&self, name: String, symbol: String) -> impl Activation<Args = R::Args> {
        RemotingAction::<_, extended_vnft_factory::io::New>::new(
            self.remoting.clone(),
            (name, symbol),
        )
    }
}

pub mod extended_vnft_factory {
    use super::*;
    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct New(());
        impl New {
            #[allow(dead_code)]
            pub fn encode_call(name: String, symbol: String) -> Vec<u8> {
                <New as ActionIo>::encode_call(&(name, symbol))
            }
        }
        impl ActionIo for New {
            const ROUTE: &'static [u8] = &[12, 78, 101, 119];
            type Params = (String, String);
            type Reply = ();
        }
    }
}
pub struct Vnft<R> {
    remoting: R,
}
impl<R> Vnft<R> {
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::Vnft for Vnft<R> {
    type Args = R::Args;
    fn burn(&mut self, from: ActorId, token_id: U256) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vnft::io::Burn>::new(self.remoting.clone(), (from, token_id))
    }
    fn grant_admin_role(&mut self, to: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vnft::io::GrantAdminRole>::new(self.remoting.clone(), to)
    }
    fn grant_burner_role(&mut self, to: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vnft::io::GrantBurnerRole>::new(self.remoting.clone(), to)
    }
    fn grant_minter_role(&mut self, to: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vnft::io::GrantMinterRole>::new(self.remoting.clone(), to)
    }
    fn mint(
        &mut self,
        to: ActorId,
        token_metadata: TokenMetadata,
    ) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vnft::io::Mint>::new(self.remoting.clone(), (to, token_metadata))
    }
    fn revoke_admin_role(&mut self, from: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vnft::io::RevokeAdminRole>::new(self.remoting.clone(), from)
    }
    fn revoke_burner_role(&mut self, from: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vnft::io::RevokeBurnerRole>::new(self.remoting.clone(), from)
    }
    fn revoke_minter_role(&mut self, from: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vnft::io::RevokeMinterRole>::new(self.remoting.clone(), from)
    }
    fn approve(
        &mut self,
        approved: ActorId,
        token_id: U256,
    ) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vnft::io::Approve>::new(self.remoting.clone(), (approved, token_id))
    }
    fn transfer(&mut self, to: ActorId, token_id: U256) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vnft::io::Transfer>::new(self.remoting.clone(), (to, token_id))
    }
    fn transfer_from(
        &mut self,
        from: ActorId,
        to: ActorId,
        token_id: U256,
    ) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vnft::io::TransferFrom>::new(
            self.remoting.clone(),
            (from, to, token_id),
        )
    }
    fn admins(&self) -> impl Query<Output = Vec<ActorId>, Args = R::Args> {
        RemotingAction::<_, vnft::io::Admins>::new(self.remoting.clone(), ())
    }
    fn burners(&self) -> impl Query<Output = Vec<ActorId>, Args = R::Args> {
        RemotingAction::<_, vnft::io::Burners>::new(self.remoting.clone(), ())
    }
    fn minters(&self) -> impl Query<Output = Vec<ActorId>, Args = R::Args> {
        RemotingAction::<_, vnft::io::Minters>::new(self.remoting.clone(), ())
    }
    fn token_id(&self) -> impl Query<Output = U256, Args = R::Args> {
        RemotingAction::<_, vnft::io::TokenId>::new(self.remoting.clone(), ())
    }
    fn token_metadata_by_id(
        &self,
        token_id: U256,
    ) -> impl Query<Output = Option<TokenMetadata>, Args = R::Args> {
        RemotingAction::<_, vnft::io::TokenMetadataById>::new(self.remoting.clone(), token_id)
    }
    fn tokens_for_owner(
        &self,
        owner: ActorId,
    ) -> impl Query<Output = Vec<(U256, TokenMetadata)>, Args = R::Args> {
        RemotingAction::<_, vnft::io::TokensForOwner>::new(self.remoting.clone(), owner)
    }
    fn balance_of(&self, owner: ActorId) -> impl Query<Output = U256, Args = R::Args> {
        RemotingAction::<_, vnft::io::BalanceOf>::new(self.remoting.clone(), owner)
    }
    fn get_approved(&self, token_id: U256) -> impl Query<Output = ActorId, Args = R::Args> {
        RemotingAction::<_, vnft::io::GetApproved>::new(self.remoting.clone(), token_id)
    }
    fn name(&self) -> impl Query<Output = String, Args = R::Args> {
        RemotingAction::<_, vnft::io::Name>::new(self.remoting.clone(), ())
    }
    fn owner_of(&self, token_id: U256) -> impl Query<Output = ActorId, Args = R::Args> {
        RemotingAction::<_, vnft::io::OwnerOf>::new(self.remoting.clone(), token_id)
    }
    fn symbol(&self) -> impl Query<Output = String, Args = R::Args> {
        RemotingAction::<_, vnft::io::Symbol>::new(self.remoting.clone(), ())
    }
}

pub mod vnft {
    use super::*;

    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct Burn(());
        impl Burn {
            #[allow(dead_code)]
            pub fn encode_call(from: ActorId, token_id: U256) -> Vec<u8> {
                <Burn as ActionIo>::encode_call(&(from, token_id))
            }
        }
        impl ActionIo for Burn {
            const ROUTE: &'static [u8] = &[16, 86, 110, 102, 116, 16, 66, 117, 114, 110];
            type Params = (ActorId, U256);
            type Reply = ();
        }
        pub struct GrantAdminRole(());
        impl GrantAdminRole {
            #[allow(dead_code)]
            pub fn encode_call(to: ActorId) -> Vec<u8> {
                <GrantAdminRole as ActionIo>::encode_call(&to)
            }
        }
        impl ActionIo for GrantAdminRole {
            const ROUTE: &'static [u8] = &[
                16, 86, 110, 102, 116, 56, 71, 114, 97, 110, 116, 65, 100, 109, 105, 110, 82, 111,
                108, 101,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct GrantBurnerRole(());
        impl GrantBurnerRole {
            #[allow(dead_code)]
            pub fn encode_call(to: ActorId) -> Vec<u8> {
                <GrantBurnerRole as ActionIo>::encode_call(&to)
            }
        }
        impl ActionIo for GrantBurnerRole {
            const ROUTE: &'static [u8] = &[
                16, 86, 110, 102, 116, 60, 71, 114, 97, 110, 116, 66, 117, 114, 110, 101, 114, 82,
                111, 108, 101,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct GrantMinterRole(());
        impl GrantMinterRole {
            #[allow(dead_code)]
            pub fn encode_call(to: ActorId) -> Vec<u8> {
                <GrantMinterRole as ActionIo>::encode_call(&to)
            }
        }
        impl ActionIo for GrantMinterRole {
            const ROUTE: &'static [u8] = &[
                16, 86, 110, 102, 116, 60, 71, 114, 97, 110, 116, 77, 105, 110, 116, 101, 114, 82,
                111, 108, 101,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct Mint(());
        impl Mint {
            #[allow(dead_code)]
            pub fn encode_call(to: ActorId, token_metadata: super::TokenMetadata) -> Vec<u8> {
                <Mint as ActionIo>::encode_call(&(to, token_metadata))
            }
        }
        impl ActionIo for Mint {
            const ROUTE: &'static [u8] = &[16, 86, 110, 102, 116, 16, 77, 105, 110, 116];
            type Params = (ActorId, super::TokenMetadata);
            type Reply = ();
        }
        pub struct RevokeAdminRole(());
        impl RevokeAdminRole {
            #[allow(dead_code)]
            pub fn encode_call(from: ActorId) -> Vec<u8> {
                <RevokeAdminRole as ActionIo>::encode_call(&from)
            }
        }
        impl ActionIo for RevokeAdminRole {
            const ROUTE: &'static [u8] = &[
                16, 86, 110, 102, 116, 60, 82, 101, 118, 111, 107, 101, 65, 100, 109, 105, 110, 82,
                111, 108, 101,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct RevokeBurnerRole(());
        impl RevokeBurnerRole {
            #[allow(dead_code)]
            pub fn encode_call(from: ActorId) -> Vec<u8> {
                <RevokeBurnerRole as ActionIo>::encode_call(&from)
            }
        }
        impl ActionIo for RevokeBurnerRole {
            const ROUTE: &'static [u8] = &[
                16, 86, 110, 102, 116, 64, 82, 101, 118, 111, 107, 101, 66, 117, 114, 110, 101,
                114, 82, 111, 108, 101,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct RevokeMinterRole(());
        impl RevokeMinterRole {
            #[allow(dead_code)]
            pub fn encode_call(from: ActorId) -> Vec<u8> {
                <RevokeMinterRole as ActionIo>::encode_call(&from)
            }
        }
        impl ActionIo for RevokeMinterRole {
            const ROUTE: &'static [u8] = &[
                16, 86, 110, 102, 116, 64, 82, 101, 118, 111, 107, 101, 77, 105, 110, 116, 101,
                114, 82, 111, 108, 101,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct Approve(());
        impl Approve {
            #[allow(dead_code)]
            pub fn encode_call(approved: ActorId, token_id: U256) -> Vec<u8> {
                <Approve as ActionIo>::encode_call(&(approved, token_id))
            }
        }
        impl ActionIo for Approve {
            const ROUTE: &'static [u8] =
                &[16, 86, 110, 102, 116, 28, 65, 112, 112, 114, 111, 118, 101];
            type Params = (ActorId, U256);
            type Reply = ();
        }
        pub struct Transfer(());
        impl Transfer {
            #[allow(dead_code)]
            pub fn encode_call(to: ActorId, token_id: U256) -> Vec<u8> {
                <Transfer as ActionIo>::encode_call(&(to, token_id))
            }
        }
        impl ActionIo for Transfer {
            const ROUTE: &'static [u8] = &[
                16, 86, 110, 102, 116, 32, 84, 114, 97, 110, 115, 102, 101, 114,
            ];
            type Params = (ActorId, U256);
            type Reply = ();
        }
        pub struct TransferFrom(());
        impl TransferFrom {
            #[allow(dead_code)]
            pub fn encode_call(from: ActorId, to: ActorId, token_id: U256) -> Vec<u8> {
                <TransferFrom as ActionIo>::encode_call(&(from, to, token_id))
            }
        }
        impl ActionIo for TransferFrom {
            const ROUTE: &'static [u8] = &[
                16, 86, 110, 102, 116, 48, 84, 114, 97, 110, 115, 102, 101, 114, 70, 114, 111, 109,
            ];
            type Params = (ActorId, ActorId, U256);
            type Reply = ();
        }
        pub struct Admins(());
        impl Admins {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Admins as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Admins {
            const ROUTE: &'static [u8] = &[16, 86, 110, 102, 116, 24, 65, 100, 109, 105, 110, 115];
            type Params = ();
            type Reply = Vec<ActorId>;
        }
        pub struct Burners(());
        impl Burners {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Burners as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Burners {
            const ROUTE: &'static [u8] =
                &[16, 86, 110, 102, 116, 28, 66, 117, 114, 110, 101, 114, 115];
            type Params = ();
            type Reply = Vec<ActorId>;
        }
        pub struct Minters(());
        impl Minters {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Minters as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Minters {
            const ROUTE: &'static [u8] =
                &[16, 86, 110, 102, 116, 28, 77, 105, 110, 116, 101, 114, 115];
            type Params = ();
            type Reply = Vec<ActorId>;
        }
        pub struct TokenId(());
        impl TokenId {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <TokenId as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for TokenId {
            const ROUTE: &'static [u8] =
                &[16, 86, 110, 102, 116, 28, 84, 111, 107, 101, 110, 73, 100];
            type Params = ();
            type Reply = U256;
        }
        pub struct TokenMetadataById(());
        impl TokenMetadataById {
            #[allow(dead_code)]
            pub fn encode_call(token_id: U256) -> Vec<u8> {
                <TokenMetadataById as ActionIo>::encode_call(&token_id)
            }
        }
        impl ActionIo for TokenMetadataById {
            const ROUTE: &'static [u8] = &[
                16, 86, 110, 102, 116, 68, 84, 111, 107, 101, 110, 77, 101, 116, 97, 100, 97, 116,
                97, 66, 121, 73, 100,
            ];
            type Params = U256;
            type Reply = Option<super::TokenMetadata>;
        }
        pub struct TokensForOwner(());
        impl TokensForOwner {
            #[allow(dead_code)]
            pub fn encode_call(owner: ActorId) -> Vec<u8> {
                <TokensForOwner as ActionIo>::encode_call(&owner)
            }
        }
        impl ActionIo for TokensForOwner {
            const ROUTE: &'static [u8] = &[
                16, 86, 110, 102, 116, 56, 84, 111, 107, 101, 110, 115, 70, 111, 114, 79, 119, 110,
                101, 114,
            ];
            type Params = ActorId;
            type Reply = Vec<(U256, super::TokenMetadata)>;
        }
        pub struct BalanceOf(());
        impl BalanceOf {
            #[allow(dead_code)]
            pub fn encode_call(owner: ActorId) -> Vec<u8> {
                <BalanceOf as ActionIo>::encode_call(&owner)
            }
        }
        impl ActionIo for BalanceOf {
            const ROUTE: &'static [u8] = &[
                16, 86, 110, 102, 116, 36, 66, 97, 108, 97, 110, 99, 101, 79, 102,
            ];
            type Params = ActorId;
            type Reply = U256;
        }
        pub struct GetApproved(());
        impl GetApproved {
            #[allow(dead_code)]
            pub fn encode_call(token_id: U256) -> Vec<u8> {
                <GetApproved as ActionIo>::encode_call(&token_id)
            }
        }
        impl ActionIo for GetApproved {
            const ROUTE: &'static [u8] = &[
                16, 86, 110, 102, 116, 44, 71, 101, 116, 65, 112, 112, 114, 111, 118, 101, 100,
            ];
            type Params = U256;
            type Reply = ActorId;
        }
        pub struct Name(());
        impl Name {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Name as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Name {
            const ROUTE: &'static [u8] = &[16, 86, 110, 102, 116, 16, 78, 97, 109, 101];
            type Params = ();
            type Reply = String;
        }
        pub struct OwnerOf(());
        impl OwnerOf {
            #[allow(dead_code)]
            pub fn encode_call(token_id: U256) -> Vec<u8> {
                <OwnerOf as ActionIo>::encode_call(&token_id)
            }
        }
        impl ActionIo for OwnerOf {
            const ROUTE: &'static [u8] =
                &[16, 86, 110, 102, 116, 28, 79, 119, 110, 101, 114, 79, 102];
            type Params = U256;
            type Reply = ActorId;
        }
        pub struct Symbol(());
        impl Symbol {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Symbol as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Symbol {
            const ROUTE: &'static [u8] = &[16, 86, 110, 102, 116, 24, 83, 121, 109, 98, 111, 108];
            type Params = ();
            type Reply = String;
        }
    }

    #[allow(dead_code)]
    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        use sails_rs::events::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum VnftEvents {
            Minted {
                to: ActorId,
                token_metadata: TokenMetadata,
            },
            Burned {
                from: ActorId,
                token_id: U256,
            },
            Transfer {
                from: ActorId,
                to: ActorId,
                token_id: U256,
            },
            Approval {
                owner: ActorId,
                approved: ActorId,
                token_id: U256,
            },
        }
        impl EventIo for VnftEvents {
            const ROUTE: &'static [u8] = &[16, 86, 110, 102, 116];
            const EVENT_NAMES: &'static [&'static [u8]] = &[
                &[24, 77, 105, 110, 116, 101, 100],
                &[24, 66, 117, 114, 110, 101, 100],
                &[32, 84, 114, 97, 110, 115, 102, 101, 114],
                &[32, 65, 112, 112, 114, 111, 118, 97, 108],
            ];
            type Event = Self;
        }
        pub fn listener<R: Listener<Vec<u8>>>(remoting: R) -> impl Listener<VnftEvents> {
            RemotingListener::<_, VnftEvents>::new(remoting)
        }
    }
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct TokenMetadata {
    pub name: String,
    pub description: String,
    pub media: String,
    pub reference: String,
}

pub mod traits {
    use super::*;
    #[allow(dead_code)]
    pub trait ExtendedVnftFactory {
        type Args;
        #[allow(clippy::new_ret_no_self)]
        #[allow(clippy::wrong_self_convention)]
        fn new(&self, name: String, symbol: String) -> impl Activation<Args = Self::Args>;
    }

    #[allow(clippy::type_complexity)]
    pub trait Vnft {
        type Args;
        fn burn(
            &mut self,
            from: ActorId,
            token_id: U256,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn grant_admin_role(&mut self, to: ActorId) -> impl Call<Output = (), Args = Self::Args>;
        fn grant_burner_role(&mut self, to: ActorId) -> impl Call<Output = (), Args = Self::Args>;
        fn grant_minter_role(&mut self, to: ActorId) -> impl Call<Output = (), Args = Self::Args>;
        fn mint(
            &mut self,
            to: ActorId,
            token_metadata: TokenMetadata,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn revoke_admin_role(&mut self, from: ActorId)
            -> impl Call<Output = (), Args = Self::Args>;
        fn revoke_burner_role(
            &mut self,
            from: ActorId,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn revoke_minter_role(
            &mut self,
            from: ActorId,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn approve(
            &mut self,
            approved: ActorId,
            token_id: U256,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn transfer(
            &mut self,
            to: ActorId,
            token_id: U256,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn transfer_from(
            &mut self,
            from: ActorId,
            to: ActorId,
            token_id: U256,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn admins(&self) -> impl Query<Output = Vec<ActorId>, Args = Self::Args>;
        fn burners(&self) -> impl Query<Output = Vec<ActorId>, Args = Self::Args>;
        fn minters(&self) -> impl Query<Output = Vec<ActorId>, Args = Self::Args>;
        fn token_id(&self) -> impl Query<Output = U256, Args = Self::Args>;
        fn token_metadata_by_id(
            &self,
            token_id: U256,
        ) -> impl Query<Output = Option<TokenMetadata>, Args = Self::Args>;
        fn tokens_for_owner(
            &self,
            owner: ActorId,
        ) -> impl Query<Output = Vec<(U256, TokenMetadata)>, Args = Self::Args>;
        fn balance_of(&self, owner: ActorId) -> impl Query<Output = U256, Args = Self::Args>;
        fn get_approved(&self, token_id: U256) -> impl Query<Output = ActorId, Args = Self::Args>;
        fn name(&self) -> impl Query<Output = String, Args = Self::Args>;
        fn owner_of(&self, token_id: U256) -> impl Query<Output = ActorId, Args = Self::Args>;
        fn symbol(&self) -> impl Query<Output = String, Args = Self::Args>;
    }
}
